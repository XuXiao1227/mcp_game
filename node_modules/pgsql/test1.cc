/*
 * testlibpq.c
 *
 *      Test the C version of libpq, the PostgreSQL frontend library.
 */
#include <stdio.h>
#include <stdlib.h>
#include <libpq-fe.h>

#include "VsDate.h"
#include "VsString.h"
#include "VsLog.h"

static void exit_nicely(PGconn *conn) {
	PQfinish(conn);
	exit(1);
}

int main(int argc, char **argv) {
	vs_log_init();
	VsString* info = vs_string_init();
	VsString* error = vs_string_init();

	const char *conninfo;
	PGconn *conn;
	PGresult *res;
	int nFields;
	int i, j;

	/*
	 * If the user supplies a parameter on the command line, use it as the
	 * conninfo string; otherwise default to setting dbname=postgres and using
	 * environment variables or defaults for all other connection parameters.
	 */
	if (argc > 1)
		conninfo = argv[1];
	else
		conninfo = "host=127.0.0.1 dbname=test user=postgres";

	/* Make a connection to the database */
	conn = PQconnectdb(conninfo);

	/* Check to see that the backend connection was successfully made */
	if (PQstatus(conn) != CONNECTION_OK) {
		fprintf(stderr, "Connection to database failed: %s",
				PQerrorMessage(conn));
		exit_nicely(conn);
	}

	//获得连接的数据库名称
	char* dbname = PQdb(conn);
	vs_log_info("数据库名称:");
	vs_log_info(dbname);
	char* user = PQuser(conn);
	vs_log_info("用户:");
	vs_log_info(user);
	char* pass = PQpass(conn);
	vs_log_info("密码:");
	vs_log_info(pass);
	char* host = PQhost(conn);
	vs_log_info("host:");
	vs_log_info(host);
	char* port = PQport(conn);
	vs_log_info("port:");
	vs_log_info(port);

	int version = PQserverVersion(conn);
	VsString* str = vs_string_init("服务器版本:");
	vs_string_append(str, (long)version);
	vs_log_info(str);
	vs_string_destroy(str);

	int transactionStatus = PQtransactionStatus(conn);
	if(transactionStatus == PQTRANS_IDLE)
	{
		vs_log_info("事务正处于空闲状态.");
	}

	long start = vs_date_millisecond();

	/*
	 * Our test case here involves using a cursor, for which we must be inside
	 * a transaction block.  We could do the whole thing with a single
	 * PQexec() of "select * from pg_database", but that's too trivial to make
	 * a good example.
	 */

	/* Start a transaction block */
	res = PQexec(conn, "BEGIN");
	if (PQresultStatus(res) != PGRES_COMMAND_OK) {
		fprintf(stderr, "BEGIN command failed: %s", PQerrorMessage(conn));
		PQclear(res);
		exit_nicely(conn);
	}

	transactionStatus = PQtransactionStatus(conn);
	if(transactionStatus == PQTRANS_INTRANS)
	{
		vs_log_info("事务正处于空闲状态，且处于一个事务中.");
	}

	/*
	 * Should PQclear PGresult whenever it is no longer needed to avoid memory
	 * leaks
	 */
	PQclear(res);

	/*
	 * Fetch rows from pg_database, the system catalog of databases
	 */
	res = PQexec(conn, "DECLARE myportal CURSOR FOR select * from pg_database");
	if (PQresultStatus(res) != PGRES_COMMAND_OK) {
		fprintf(stderr, "DECLARE CURSOR failed: %s", PQerrorMessage(conn));
		PQclear(res);
		exit_nicely(conn);
	}
	PQclear(res);

	res = PQexec(conn, "FETCH ALL in myportal");
	if (PQresultStatus(res) != PGRES_TUPLES_OK) {
		fprintf(stderr, "FETCH ALL failed: %s", PQerrorMessage(conn));
		PQclear(res);
		exit_nicely(conn);
	}

	/* first, print out the attribute names */
	nFields = PQnfields(res);
	for (i = 0; i < nFields; i++)
		printf("%-15s", PQfname(res, i));
	printf("\n\n");

	/* next, print out the rows */
	for (i = 0; i < PQntuples(res); i++) {
		for (j = 0; j < nFields; j++)
			printf("%-15s", PQgetvalue(res, i, j));
		printf("\n");
	}

	PQclear(res);

	/* close the portal ... we don't bother to check for errors ... */
	res = PQexec(conn, "CLOSE myportal");
	PQclear(res);

	/* end the transaction */
	res = PQexec(conn, "END");
	PQclear(res);

	long end = vs_date_millisecond();
	vs_string_clear(info, "耗时");
	vs_string_append(info, end - start);
	vs_string_append(info, "ms.");
	vs_log_info(info);

	const char* cmd = "select * from test limit 2 offset 0;";
	vs_string_clear(info, "执行命令:");
	vs_string_append(info, cmd);
	vs_log_info(info);
	res = PQexec(conn, cmd);

	int resStatus = PQresultStatus(res);
	vs_string_clear(info, "命令返回值:");
	vs_string_append(info, (long)resStatus);
	vs_log_info(info);

	if (resStatus != PGRES_TUPLES_OK) {
		vs_string_clear(error, "cmd failed:");
		vs_string_append(error, PQerrorMessage(conn));
		vs_log_error(error);
		PQclear(res);
		exit_nicely(conn);
	}
	else	//cmd 执行成功
	{
		vs_string_clear(info, "命令执行成功:");
		vs_string_append(info, cmd);
		vs_log_info(info);

		long rows = (long)PQntuples(res);
		vs_string_clear(info, "符合记录的条数:");
		vs_string_append(info, rows);
		vs_log_info(info);

		long colCount = (long)PQnfields(res);
		vs_string_clear(info, "每行记录的列数:");
		vs_string_append(info, colCount);
		vs_log_info(info);

		for(int i = 0; i < colCount; i++)
		{
			vs_string_clear(info, "第");
			vs_string_append(info, (long)i);
			vs_string_append(info, "列名称：");
			vs_string_append(info, PQfname(res, i));
			vs_log_info(info);

			vs_string_clear(info, "第");
			vs_string_append(info, (long)i);
			vs_string_append(info, "列字节数：");
			vs_string_append(info, (long)PQfsize(res, i));
			vs_log_info(info);
		}

		vs_string_clear(info, "开始遍历记录集");
		vs_log_info(info);
		for(int i = 0; i < rows; i++)
		{
			for(int j = 0; j < colCount; j++)
			{
				vs_string_clear(info, "第");
				vs_string_append(info, (long)i);
				vs_string_append(info, "行，第");
				vs_string_append(info, (long)j);
				vs_string_append(info, "列的值为:");
				vs_string_append(info, PQgetvalue(res, i, j));
				vs_log_info(info);
			}
		}

		PQclear(res);
	}

	vs_string_clear(info, "测试使用prepare方式执行sql语句.");
	vs_log_info(info);
	const char* insert = "insert into test(id, name, createtime, index) values($1, $2, $3, $4);";
	res = PQprepare(conn, "myinsert", insert, 4, NULL);
	resStatus = PQresultStatus(res);
	if(resStatus == PGRES_COMMAND_OK)
	{
		vs_string_clear(info, "prepare准备就绪.");
		vs_log_info(info);
		PQclear(res);

		const char *paramValues[4];
		paramValues[0] = "4";
		paramValues[1] = "hello \"''''world!";
		paramValues[2] = "1234";
		paramValues[3] = "999999999999";
		res = PQexecPrepared(conn, "myinsert", 4,
				paramValues,
				NULL, NULL, 0);

		resStatus = PQresultStatus(res);
		if (resStatus == PGRES_TUPLES_OK) {
			vs_string_clear(info, "prepare命令执行成功.");
			vs_log_info(info);
		}
		else
		{
			vs_string_clear(info, "prepare命令执行失败.");
			vs_log_info(info);
		}
		PQclear(res);
	}
	else
	{
		vs_string_clear(error, "prepare准备失败.");
		vs_string_append(error, PQerrorMessage(conn));
		vs_log_error(error);
		PQclear(res);
	}

	/* close the connection to the database and cleanup */
	PQfinish(conn);

	vs_string_destroy(info);
	vs_log_close();
	return 0;
}
